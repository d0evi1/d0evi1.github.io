---
layout: post
title: 延迟反馈建模FNW介绍
description: 
modified: 2021-4-20
tags: 
---

twitter在《Addressing Delayed Feedback for Continuous Training with Neural Networks in CTR prediction》提出了一种FNW的逻辑：

# 摘要

在展示广告中，一个挑战是特征分布和点击率（CTR）可能会因为季节性变化、广告活动的变化和其他因素而随时间发生大幅度变化。为了跟上这些变化，主要的策略是持续在新鲜数据上训练预测模型，以防止它们变得过时。然而，在许多广告系统中，**正向标签（postive label）只有在可能很长且随机的延迟之后才会被观察到**。这些延迟的标签对连续训练中的数据新鲜性构成了挑战：在它们被训练算法摄取时，新鲜数据可能没有完整的标签信息。

**naive策略是：将任何数据点视为负例，直到正向标签变得可用，往往会低估CTR，导致用户体验不佳和广告商的性能次优**。本文的重点是**确定最佳loss函数和模型的组合**，以便在存在延迟标签的情况下，从连续数据流中进行大规模学习。在这项工作中，我们比较了5种不同的损失函数，**其中3种是首次应用于这个问题**。我们在离线设置中使用浅层和深层模型架构，对公共和专有数据集进行了基准测试。我们还讨论了在生产环境中实现每种损失函数的工程成本。最后，我们对表现最佳的几种方法进行了在线实验，以验证它们在连续训练方案中的性能。在离线训练6.68亿内部数据点时，我们提出的方法比之前的最先进水平提高了3%的相对交叉熵（RCE）。在在线实验中，我们观察到每千次请求的收入（RPMq）比naive logloss增加了55%。

# 1.介绍

许多广告商会选择在用户执行了预定义动作(例如点击他们的广告或访问他们的网站)之前不支付任何曝光（impression）费用。这个问题在广告领域是众所周知的，并引入了诸如每次点击成本（CPC:cost-per-click）和每次转化成本（CPA:cost-per-conversion）等模型，允许广告商只对预定义的消费（engagements）进行付费。这些基于绩效的付费模型会**估计一次曝光能够产生的特定消费(engagement)的概率**。

在展示广告中，由于特殊事件、新活动和其他因素，特征和点击率（CTR）分布可能会经历巨大的变化。图1和图2通过时间展示了这些变化。为了解决这个问题，Twitter的广告预测模型会不断在线训练新鲜数据，即它们接收连续的数据流，并在新数据到达时更新模型（见图3）。

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/da361c2b0ff27680a5e1e43889f5bf8867d79e198e30acb386b8e9521ad5e91a52d85ee1690062a87bbf2d7eeaa4f3ae?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;fname=1.jpg&amp;size=750">

图1 在参照日之后每个小时的带有新广告活动ID(campaign ID)的流量百分比

在上述场景中遇到的主要挑战是**用户行为反馈的延迟**。一些消费（engagements），例如广告上的一次点击或广告视频的一次MRC观看，可能会在广告展示后的1分钟、1小时甚至1天后发生。相应的挑战是，**在为广告曝光分配label之前（随后在该数据上进行训练），是否需要等待一个固定的时间窗口，还是根据某些启发式规则来决定label**。

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/7043544deeeefcd9877902d60656c2059d6d6914a635c9ae5c428d4ff1a2ca8882a20b8b5b9a8a02802300f578f9a64b?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;fname=2.jpg&amp;size=750">

图2 连续特征值在3天内的分布情况。

- **早前方法**的主要缺点是：在等待过程中模型可能会变得过时，以及维护数据缓存所需的额外基础设施成本。
- 随后出现的**实时方法**的问题是：训练涉及到错误地将样本标记为负例，导致负例数量比实际数据分布中更多。

未知的是，我们应该将理想的窗口长度设置成多少，以便在模型训练的延迟和假负例（FN）率（即由于窗口太短而错误地将示例标记为负例）之间找到平衡。

内部实证结果显示，即使模型更新延迟5分钟，也可能在性能方面造成极大的损害。在【naive的连续学习方法】中，小批量具有负标签的训练样本会立即被模型吸收，因而，**模型始终是最新的，会随时间发生严重的特征分布变化（feature distribution shift）**。因为不需要存储尚未被点击的实例的额外快照，从技术上讲，这种方法允许我们无限期地等待，直到观察到正向标签。然后，它可以立即引入到模型中，如图3所示。

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/3bfa599ca90d3b0b24986c50388988a4705c1af3dc0960ba7ad5302ea5a41f93a3b1e783e368326149b1d47ab208cca0?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;fname=3.jpg&amp;size=750">

图3 连续学习框架

**这种方法的主要缺点是：所有样本初始都被标记为负例，即使用户最终可能会消费（engage）它们**。或者，数据样本保持未标记状态（unlabeled）直到发生消费(engagement)行为，并且消费（engagement）概率被认为依赖于从曝光发生以来经过的时间，如[3]中所述，就需要定期收集和存储数据的快照，以捕捉消费延迟分布( engagement delay distribution)。尽管时间依赖性的假设是有效的，但鉴于需要多次存储数据点（每个快照一次）以批量模式训练模型，这将导致基础设施成本大幅增加，并且如果没有激进的下采样，训练数据会随着时间的推移而增长。最后但同样重要的是，**像[13]中提出的固定时间窗口将允许我们在训练之前获得大部分正向标签，但仍然会导致那些落在固定窗口之外进行消费的FN标签**。因此，处理假负例（FN）的问题仍然存在，并且模型还有变得过时的额外风险。

在这项工作中，我们设计了一个模型，用于预测特定用户在Twitter平台上点击视频广告的概率（pCTR）。通过这一努力，我们在两个不同的数据集上离线比较了两类不同的模型架构和五种不同的损失函数。随后，我们选择了表现最佳的架构和损失函数，并通过在线实验对它们进行评估。

- 第一种模型架构是一个**简单的逻辑回归模型**，由于其简单性、良好性能以及在线训练中容易摄取和处理新训练示例的特点，在展示广告行业中得到了广泛使用[3, 13]。
- 第二种模型采用了**deep&wide的架构**[5]，旨在应对推荐系统中使用的复杂和多样化的特征。

我们测试的**五种损失函数**，包括：

- 对数损失（log loss）
- **假负例加权损失（FN weighted loss）**
- **假负例校准（FN calibration）**
- 正未标记损失[7, 8]（positive unlabeled loss）
- 延迟反馈损失[3]（delayed feedback loss）

在这些中，对数损失通常用于CTR预测[14]。

在线实验中使用了连续学习，我们认为这在基础设施成本、生产化便利性方面提供了最佳权衡，并且具有显著优势，即模型始终在新鲜数据上进行训练。

虽然通过在线梯度下降的连续或在线训练在浅层（线性或基于核的）模型中得到了广泛应用[12]，但关于深度神经网络的连续学习的研究相对较少[21]。这尤其具有挑战性，因为目标函数是非凸的，并且已经提出了替代方法，如对冲策略[24]，来解决这个问题。据我们所知，这是**第一次使用深度学习模型来估计展示广告中的pCTR，同时解决延迟反馈问题**。鉴于在线训练对深度神经网络来说难以采用，这项工作旨在对延迟反馈问题进行基准测试，并提出可行的解决方案，而不增加额外的工程成本。我们考虑的三种损失函数:

- **正未标记（PU：positive unlabeled）**
- **假负例加权（FN weighted）**
- **假负例校准（FN calibration）**

是首次应用于这个问题，而后两种基于重要性采样。我们的结果表明，线性模型和小数据集上的好性能并不一定能转化为深度模型的同等性能。例如，延迟反馈损失(（delayed feedback loss）)在使用公共数据集的线性模型上导致了最佳的相对交叉熵（RCE），但在Twitter数据上使用深度模型时，却被所有提出的损失函数超越（RCE增加了2.99%）。损失函数的有效性也随着可用数据量的变化而变化。我们希望这篇论文能作为在连续方式下训练深度学习模型进行广告点击预测任务时使用哪种损失函数的指南。

# 2 相关工作

为了确保模型始终在新鲜数据流上进行训练，**一些样本被错误地标记为负例或保持未标记状态（unlabeled）**。一旦用户对广告产生消费，相同的数据点将以正标签呈现给模型。在[13]中，**他们声称使用了一个足够长的时间窗口，以显著减少经验CTR与真实情况之间的偏差（仍然一部分曝光被错误地标记为负例）**。尽管大多数方法忽视了可用的时间延迟信息（即自曝光以来经过的时间以及用户与广告交互前的时间），但其中一些方法通过联合训练延迟模型以及CPC或CPA模型来利用时间延迟[3, 28]。在以下各节中，我们描述了五种不同的方法，这些方法构成了解决FN问题的潜在解决方案。我们进一步讨论了它们各自的挑战。

## 2.1 重要性采样（Importance Sampling）

模型相对于**数据分布$ \mathbf{p} $**的交叉熵由下式给出：

$$
L(\theta) = -\mathbb{E}_{\mathbf{p}}[\log f_{\theta}(y|x)] = -\sum_{x,y} \mathbf{p}(x, y) \log f_{\theta}(y|x) \quad (1) 
$$

其中：

- $ x $是与特定请求（与用户和广告相关）相关的特征，
- $ y $是表示用户是否消费（engagement）的二元label
- $ f_{\theta} $是试图预估$ \mathbf{p} $的模型。
- $\theta$：模型参数

如前所述，**在在线训练场景中，直到观察到正标签，否则样本被引入当成负例**。这导致模型观察到一个**有偏分布$ \mathbf{b} $**，而不是实际的数据分布。因此，我们不能从$ \mathbf{p} $中采样，只能访问来自不同分布$ \mathbf{b} $的样本。通过应用适当的加权方案，我们可以使用以下公式获得公式(1)中期望的无偏估计：

$$
\mathbb{E}_{\mathbf{p}}[\log f_{\theta}(y|x)] = \mathbb{E}_{\mathbf{b}}\left[ \frac{\mathbf{p}(x, y)}{\mathbf{b}(x, y)} \log f_{\theta}(y|x) \right] \quad (2)
$$

**权重 $ w(x, y) = \frac{p(x,y)}{b(x,y)} $ 对应于重要性权重，旨在纠正在不同分布上进行平均的事实**。使用来自不同、有偏的分布 $ b $ 的样本，可以通过以下方式估计等式(2)中的期望值：

$$
\frac{1}{N} \sum_{n} w(x_n, y_n) \log f_{\theta}(y_n | x_n)
$$


**使用一个分布中的样本来估计另一个分布的期望值这种方法称为重要性采样**。重要性采样已在不同情境中得到广泛使用，包括反事实分析，在[2]中作者讨论了涉及的假设以及如何将这种技术应用于计算广告中以估计任何量的反事实期望。**在这种情况下使用重要性采样的最大挑战是我们需要估计权重 $ w(x, y) $**。从此处开始，出于简洁性，我们使用 $ f_{\theta}(x) $ 来表示 $ f_{\theta}(y = 1 \mid x) $。

## 2.2 逆倾向性加权（Inverse Propensity Weighting）

逆倾向性加权在因果推断中得到了广泛应用，其中**某些总体中的样本可能被低估**。通过在estimator中对个别样本使用适当权重，可以调整实际总体与样本之间的差异[1]。**当抽样概率已知时，就使用这个概率的倒数来加权观察结果**。倾向性得分，记作:

$$ p(x) = P(T = 1 \mid X = x) 
$$

是给定一组协变量时样本将被分配特定处理的概率。在假设处理不是随机分配的情况下，反事实相当于假设所有总体样本都以等概率被分配任何处理的等效估计。在点击率预估的背景下可以采用类似的方法，其中treatment相当于广告被赋予一个真实label。在任何问题中应用这种技术时需要考虑的一个要求是，倾向性权重需要通过一个单独的参考模型来估计。


## 2.3 PU learning(Positive - Unlabeled Learning)

**另一种方法集不会明确识别带有负标签的数据，而只从正例（P）和未标记（U）样本中学习，这与传统的分类设置不同，在传统分类设置中，正例和负例都是可用的**。当获取已标记样本不可能或成本非常高时，就会出现这种设置，例如在文本分类[10]、分子生物学[9]中，但这种方法也被应用于异常值检测[25]和时间序列分类[23]。

**这种情况下，可用的训练数据由一组不完整（随机抽样）的正例和一组unlabeled样本组成**，这些样本可能是正例或负例，导致需要一种不同的训练过程。关于训练数据的一个关键假设是：

数据从$p(x, y, s)$分布上随机抽取的，对于每个被抽取的三元组<x,y,s>，只会记录 <x, s>。这里:

- s是观察到的label
- y是实际label，可能尚未发生

与此同时，假设：已标记的正例是从所有正例中以完全随机的方式选中，例如:

$$
p(s = 1 \mid x, y = 1) = p(s = 1 \mid y = 1) 
$$

这种情况下，我们首先训练一个分类器 $ g(x) = p(s = 1 \mid x) $ ，来估计：给定一条样本的原始标签为正例（y = 1）时，该样本被标记为正例（s=1）的概率[9]，因为

$$
p(s = 1 | y = 1) = \frac{1}{n_P} \sum_{x \in P} g(x)
$$

其中：

- $ n_P $ 是正例 P 的基数。

接下来，每个unlabel样本可以被看成是以下两者的组合：

- 一个正例，它的权重与$ p(y=1 \mid x, s=0)$ 成比例 （观察是unlabeled，实际是个正例），其中所有正例都有单位权重
- 一个负例，具有一个互补权重 $1-p(y=1 \mid x, s=0) $（观察是unlabeled，实际是个负例）

该weight可以表示为：

$$
p(y = 1 | x, s = 0) = \frac{1 - p(s = 1 | y = 1)}{p(s = 1 | y = 1)} \times \frac{p(s = 1 | x)}{1 - p(s = 1 | x)}
$$

最后，可以使用这些权重和标准训练过程在可用数据上训练分类器。
在之前的研究中，[19] 通过执行逻辑回归，并优化线性函数的squared weights求和和以及weighted logit loss的和，学习了给定输入观察到正标签的条件概率。在这种设置中：

- unlabeled样本具有**单位权重**
- 正样本权重由 **$n_U/n_P$的比值**确定

PU问题也通过对分类器进行聚合来解决，这些分类器被训练以区分P数据和U数据的随机子样本[22]。

在文献[8]和[7]中，du Plessis等人首次提出了一个无偏的非凸风险估计器，并分析了从数据中估计类先验时的超额风险。在标准二分类中，分类风险（classification risk）由下式给出：

$$
\widehat{R}_{PN}(f_{\theta}) = p(y = 1)E_{p(x|y=1)}[l(f_{\theta}(x))] + p(y = 0)E_{p(x|y=0)}[l(1 - f_{\theta}(x))] 
$$

其中：

- $ l $ 是损失函数。

由于： 

$$ 
p(x) = p(y = 1)p(x \mid y = 1) + p(y = 0)p(x \mid y = 0) 
$$

最后一项可以表示为：

$$
p(y = 0)E_{p(x|y=0)}[l(1 - f_{\theta}(x))] =\\
E_{p(x)}[l(1 - f_{\theta}(x))] - p(y = 1)E_{p(x|y=1)}[l(1 - f_{\theta}(x))]
$$

因此，分类风险可以用以下表达式近似：

$$
\widehat{R}_{PU}(f_{\theta}) = p(y = 1)E_{p(x|y=1)}[l(f_{\theta}(x))] \\
- p(y = 1)E_{p(x|y=1)}[l(1 - f_{\theta}(x))] \\
+ E_{p(x)}[l(1 - f_{\theta}(x))] \quad (3)
$$

其中：

- $ p(x) $ 对应于所有未标记示例的边际分布。

根据文献[18]，这个无偏风险估计器如果训练的模型过于灵活，可能会产生负的经验风险，这使得这个损失函数更难以用神经网络优化，并容易过拟合。

## 2.4 延迟反馈模型

文献[3]中提出的方法对CPA（每次行动成本）进行建模，并考虑了自广告点击以来经过的时间，并且不涉及匹配窗口。**在这种情况下，延迟反馈问题的处理方式如下：只有当实际观察到正标签(positive labels)时，训练样本才被标记为正向，否则被视为unlabeled，类似于PU learning方法**。在模拟点击后归因的情况下，这意味着负标签不可能发生，因为转化可能在任何未来的时间内发生。大多数只从正样本和unlabeled样本中学习的方法[9, 19]假设缺失标签的正样本的概率是恒定的。然而，**根据[3]的说法，最近的点击不太可能被赋予真实label，因为经过的时间不够长，即正样本的概率是与时间相关的**。因此，他们使用第二个模型，该模型非常类似于生存时间分析模型[15]，以捕捉点击和转化之间的预期延迟。这与预测用户最终是否会转化的模型是分开的，但两个模型是联合训练的。在这种方法中，

- 随机变量 $ Y \in \lbrace 0, 1 \rbrace $ 表示一次转化是否已经发生
- 另一个独立的随机变量 $C \in \lbrace 0, 1\rbrace$ 表示用户最终是否会真实转化

**一旦训练了两个模型，只会保留预估转化率的模型，即 $ P(c = 1 \mid x) $**，而转化延迟模型 $ P(d \mid x, c = 1) $ 则被丢弃。标准逻辑回归模型代表点击率（CTR），而延迟则假设为指数（非负）分布，即：

$$
P(d|x, c = 1) = \lambda(x) \exp(-\lambda(x)d) \quad (4) 
$$


因此，$ y = 0 $ 可能发生在两种不同的情况下：

- 经过的时间$e$比转化时间$d$短，即 $ e < d $
- 用户永远不会转化，即 $ c = 0 $

尽管该模型被应用于CPA（cost-per-conversion）模型，它也适用于本文的CPC(cost-per-click)模型。图4说明了点击时间也遵循指数分布，这使得这个模型成为一个适当的解决方案。作为[3]中呈现模型的扩展，[28]建议了一个非参数延迟反馈模型（NoDeF），以在不假设任何参数分布（如指数或威布尔分布）的情况下捕捉时间延迟。**该模型假设每个样本都有一个隐藏变量，这表明这个动作最终是否会导致转化**。对于参数估计，使用了期望最大化（EM）算法[6]。然而，采用这些方法将需要用一个单独的模型来估计时间延迟，并显著增加基础设施成本和将这样一个系统投入生产的复杂性。

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c121feb5a77ecdd3f8978d3bd091d9293b8e6e05e2d1ac09ca92c3a3d7b3387d96a9589fe9d3d9392e8258682047043b?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;fname=4.jpg&amp;size=750">

图4 训练广告的点击延迟时间分布（超过5分钟）。对应于在纠正了审查分布的累积分布函数（CDF）之后的分布

## 2.5 Delayed Bandits

延迟反馈在马尔可夫决策过程（MDPs）[16, 27]的背景下已得到广泛考虑，但当延迟不受限制时，其应用变得更加具有挑战性。在[26]中，作者提出了**离散时间随机多臂老虎机模型**，来**解决可能存在审查反馈的长延迟问题，即不可观察的反馈**。他们涵盖了这两种模型的两个不同版本：

- 未审查模型（uncensored model）：允许在任意长的延迟后观察转化；
- 审查模型（censored model）：它在行动后施加了$m$个时间步长的限制，在此之后，转化不再可观察。

在每一轮中，agent收到的reward对应于在时间 $ t $ 观察到的转化数量。然而，与之前的方法不同，这些模型假设已知延迟分布。他们认为这是一个有效的假设，因为分布可以从历史数据中估计，并且还声称可以在线方式在不增加成本的情况下估计延迟分布，前提是它被所有行动共享。

# 3 提出的方法

在本工作中，我们采用了一种连续训练方案，它建议：**我们可以潜在等待从广告曝光以后的无限时间，直到最终观察到真实正向消费**。从历史上看，这是通过摄取所有带有负标签的样本来处理的，直到用户记录了正向消费。因此，**有偏的数据分布（即观察到的分布），包含了所有从实际数据分布中标记为负的样本**。相应地，在有偏分布中的正样本对应于原始数据分布中的所有正样本。

## 3.1 模型架构

本节描述了正在考虑的模型的架构细节。

### 3.1.1 逻辑回归

我们使用了一个标准逻辑回归模型，该模型在展示广告领域得到了非常广泛的应用[3, 13]：

$$
f_{\theta}(x) = \frac{1}{1 + \exp(-w_c \cdot x)} = \sigma(w_c \cdot x)
$$

其中：

- $ \sigma(\cdot) $ 对应于sigmoid函数
- 输入 x 是与特定请求相关的用户和广告候选的成千上万个特征的稀疏表示。

### 3.1.2 Wide&deep模型

这个深度模型由一个宽组件组成，对应于一个广义线性模型，以及一个深组件，对应于一个标准前馈神经网络。宽组件处理原始输入特征和转换后的特征，例如交叉乘积特征，为广义线性模型添加非线性。深组件将高维稀疏特征转换为嵌入向量，将分类特征转换为密集的、低维的表示形式。
与前一个模型类似，特征包括用户特征、上下文特征和广告特征。模型对CTR的预测由下式给出：

$$
f_{\theta}(x) = \sigma(w_{wide}^T \cdot [x, \phi(x)] + w_{deep}^T \cdot {\alpha^{(l_f)}} + b)
$$

其中：

-  $ w_{wide} $ 对应于wide组件的权重，
- $ w_{deep} $ 对应于deep组件的权重，
- $ \phi(x) $ 是交叉乘积变换，
- $ \alpha^{(l_f)} $ 是deep分支的最终层的激活

## 3.2 损失函数

### 3.2.1 延迟反馈损失（Delayed feedback loss）

在这个版本的损失函数中，假设**时间延迟遵循指数分布**，并且这个模型与逻辑回归模型或深度模型联合训练。假设:

- $ \lambda(x) = \exp(w_d \cdot x) $ 
- $ w_d $ 是pCTR模型的参数

我们针对参数 $ \theta $ 和 $ w_d $ 优化正则化对数似然：

$$
\underset{\theta, w_d}{\text{arg min}} \ L_{DF}(\theta, w_d) + \alpha (\| \theta \|^2_2 + \| w_d \|^2_2)
$$

其中：

- $ \alpha $ 是正则化参数，
- $ L_{DF} $ 是延迟反馈损失函数，其定义如下：

$$
\begin{aligned}
L_{DF}(\theta, w_d) &= -\sum_{x,y=1} \log f_{\theta}(x) + \log \lambda(x) - \lambda(x)d \\
&- \sum_{x,y=0} \log[1 - f_{\theta}(x) + f_{\theta}(x) e^{(-\lambda(x)e)}] \quad (5)
\end{aligned}
$$

其中：

- $ f_{\theta}(x) $ 是pCTR模型的输出
- $d$： 是**正样本的点击时间**
- $e$： 表示**自广告曝光以来经过的时间**

这个损失函数可以以更数值稳定的方式计算如下：

$$
L_{DF}(\theta, w_d) = -\sum_{x,y} \log f_{\theta}(x) - \sum_{x,y=1} w_d \cdot x - \lambda(x)d \\
- \sum_{x,y=0} \log[\exp(-f_{\theta} (x)) + \exp(-\lambda(x)e)]
$$

### 3.2.2 PU-loss（Positive-Unlabeled loss）

在这一部分中，我们考虑在假负例（FN）设定下使用PU损失，**通过将有偏训练数据中的所有负样本视为未标记**。根据等式(3)，可以推导出以下损失函数：

$$
L_{PU}(\theta) = -\sum_{x,y=1} [\log f_{\theta}(x) - \log(1 - f_{\theta}(x))] - \sum_{x,y=0} \log(1 - f_{\theta}(x)) \quad (6)
$$

从经验上看，这可以被看成是：对正样本和负样本都使用传统的log loss。另外，**当观察到正例时，都会朝着负梯度的相反方向迈出一步**。这个假设是合理的，因为对于每个正样本，都会基于在一个假负样本的梯度上进行参数更新。

### 3.2.3 假负例加权（Fake Negative Weighted loss）

该损失函数依赖于重要性采样。**在我们的训练设置中，样本会被标记为负例，并被引入到训练pipeline中，接着当用户发生消费时会复制出一个正标签**。为了对该损失函数进行公式化，我们依赖以下假设：

$$
b(x|y = 0) = p(x) \\
b(x|y = 1) = p(x|y = 1)
$$

其中：

- $b$：是有偏的观察到的分布
- $p$：是实际的数据分布

我们知道：

$$
b(y = 0) = \frac{1}{1+p(y=1)} 
$$

因为：**所有样本最初都被标记为负例**。

(1)中的损失函数可以写成：

$$
-\sum_{x,y} p(y = 1|x) \log f_{\theta}(x) + p(y = 0|x) \log f_{\theta}(y = 0|x) \\

 = -\sum_{x,y} \frac{b(y = 1|x)}{p(y = 1|x)} \log f_{\theta}(x) + \frac{b(y = 0|x)}{p(y = 0|x)} \log f_{\theta}(y = 0|x) \quad (7)
$$

在有偏分布中观察到**用户正向消费的概率**是：

$$
b(y = 1|x) = \frac{b(y = 1)b(x|y = 1)}{b(y = 1)b(x|y = 1) + b(y = 0)b(x|y = 0)}
$$

利用上述假设，并分配 $ w(x) := \frac{1}{1+p(y=1 \mid x)} $，可以表示为：

$$
b(y = 1|x) = \frac{w(x)p(y = 1)p(x|y = 1)}{w(x)p(y = 1)p(x|y = 1) + w(x)p(x)} \\
= \frac{p(y = 1|x)p(x)}{p(y = 1|x)p(x) + p(x)} \\
= \frac{p(y = 1|x)}{1 + p(y = 1|x)} \quad (8)
$$

类似地，**用户不消费的概率**是：

$$
b(y = 0|x) = 1 - b(y = 1|x) = \frac{1}{1 + p(y = 1|x)} \quad (9)
$$

通过将(8)和(9)替换到等式7中，我们得到以下表达式：

$$
\begin{aligned}
L_{IS}(\theta) &= -\sum_{x,y} b(y = 1|x) (1 + p(y = 1|x)) \log f_{\theta}(x) \\
&+ b(y = 0|x)p(y = 0|x) (1 + p(y = 1|x)) \log f_{\theta}(y = 0|x) \quad (10)
\end{aligned}
$$

因此，我们可以：

- 用 $ (1 + p(y = 1 \mid x)) $ 来加权正样本
- 用 $ (1 - p(y = 1 \mid x)) \cdot (1 + p(y = 1 \mid x)) $ 来加权负样本

**由于我们不能直接获取 $ p $，我们可以用模型估计 $ f_{\theta} $ 来替代它**，只要 $ f_{\theta} $ 收敛于 $ p $，这在以下段落中将得到证明。

依赖于(8)和(9)，并通过在重要性权重中用 $ f_{\theta} $ 替代 $ p $，(10)可以重写为：

$$
\begin{aligned}
L_{IS}(\theta) = &-\sum_{x,y} \frac{p(y = 1|x)}{1 + p(y = 1|x)} [(1 + f_{\theta}(x))]\log f_{\theta}(x) \\
&+ \frac{1}{1 + p(y = 1|x)} [(1 - f_{\theta}(x))(1 + f_{\theta}(x))] \log(1 - f_{\theta}(x))
\end{aligned}
$$

$[\cdot]$括号中的项在计算loss对输入的梯度时不予考虑。最后，$ L_{IS}(\theta) $ 相对于 $ f_{\theta} $ 的梯度可以写成：

$$
\frac{\partial L_{IS}}{\partial f_{\theta}} = -\frac{p(y = 1|x)}{1 + p(y = 1|x)} \frac{1 + f_{\theta}(x)}{f_{\theta}(x)} + \frac{1 + f_{\theta}(x)}{1 + p(y = 1|x)}  \\
= \frac{(1 + f_{\theta}(x))(f_{\theta}(x) - p(y = 1|x))}{(1 + p(y = 1|x))f_{\theta}(x)} \quad (11) 
$$

注意，对于 $ p(y = 1 \mid x) \in (0, 1] $：

- 当 $ \frac{\partial L_{IS}}{\partial f_{\theta}} = 0 $ 时，那么 $ f_{\theta}(x) = p(y = 1 \mid x) $，即只要 $ f_{\theta}(x) > 0 $，$ f_{\theta}(x) $ 就收敛于 $ p(y = 1 \mid x) $
- 当 $ f_{\theta}(x) > p(y = 1 \mid x) $ 时，$ \frac{\partial L_{IS}}{\partial f_{\theta}} > 0 $
- 当 $ f_{\theta}(x) < p(y = 1 \mid x) $ 时，$ \frac{\partial L_{IS}}{\partial f_{\theta}} < 0 $。

这表明FN weighted loss导致 $ f_{\theta}(x) = p(y = 1 \mid x) $，并且梯度始终指向正确的方向。

### 3.2.4 假负例校准(Fake negative calibration)

在该方法中，模型会估计有偏分布$b$，接着，在解等式8求 $ p(y = 1 \mid x) $ 后使用以下变换：

$$
p(y = 1|x) = \frac{b(y = 1|x)}{1 - b(y = 1|x)}
$$

这总是一个有效的分布，因为，**对于在有偏分布中的每个正例，都会观察到一个FN**，即 $ b(y = 1 \mid x) \leq 0.5 $ 且 $ p(y = 1 \mid x) \leq 1 $。为简洁起见，我们称这种方法为FN校准。

# 4.实验

## 4.1 Setup

### 4.1.1 离线指标

为了比较正在考虑的不同模型架构和loss函数，我们首先进行了离线实验。离线实验被用来验证所提出的损失函数是否适用于CTR预测问题，并且使用了两个不同的数据集进行模型的训练和测试，一个内部数据集和一个公共数据集。在离线设置中，我们在本文中关注并报告的指标包括：评估集上的logloss（其中不包含假负例）、相对交叉熵（RCE）和准确率-召回率曲线下面积（PR-AUC）。RCE对应于相对于稻草人预测，或者说是naive预测的改进，通过交叉熵（CE）来衡量。naive预测对应于不考虑用户和广告特征的情况，例如，它总是预测训练集的平均CTR。假设naive预测的平均CE是 $ C_{naive} $ ，要评估的预测的平均CE是 $ C_{pred} $ ，那么RCE定义为 $ (CE_{naive} - CE_{pred}) \times 100/CE_{naive} $ 。请注意，CE越低，预测的质量越好，因此RCE越高。使用RCE的好处是，我们可以确信地估计模型是在低估还是高估了天真预测的性能。**PR-AUC是一个更常用的指标，并且在数据倾斜的情况下比AUC更敏感**。

### 4.1.2 在线指标

最有希望的离线结果的模型和损失函数在线上环境中进行了进一步评估，因为期望的应用是连续训练。线上环境反映了实际性能，这决定了哪种方法最适合处理延迟反馈问题。然后，在Twitter数据的保留评估数据集上执行评估，以比较“对照”方法和“A/B测试框架中的处理”方法的性能。通过在评估日期结束后等待最多9小时以获取消费标签，已从这个保留数据集中移除了假负例。在这种设置中报告了两个关键指标：汇总相对交叉熵（汇总RCE）和每千次请求的收入（RPMq）[20]。汇总RCE用于在控制和实验之间进行RCE的公平比较，否则每个模型都将在自己的流量上进行验证，并且是通过评估两个模型生成的汇总流量来衡量模型泛化能力的一个指标。RPMq代表每1000次广告请求产生的收入。通过展示更高质量的广告来增加用户消费可能会导致RPMq增加，但RPMq也可能仅通过每次请求提供更多广告而上升，而不考虑其质量。因此，更高的RPMq是可取的，但这个指标需要与CTR一起考虑，因为高RPMq与低CTR可能会损害用户体验并导致负面的长期影响。

### 4.1.3 超参数

用于离线实验的超参数包括：随机梯度下降（SGD）优化器，学习率0.02；衰减率0.000001；批量大小128；用于延迟反馈损失的学习率是0.005，延迟反馈模型的L2正则化参数是2。我们使用了固定数量的箱位将分类和连续特征进行离散化。宽与深模型的深度部分由4层组成，大小为[400, 300, 200, 100]，并且采用泄漏的修正线性单元（ReLU）作为中间层的激活函数。权重是使用Glorot [11]初始化的。相同的超参数被用来初始化线上模型。

## 4.2 数据

### 4.2.2 离线Twitter数据。

对于基于内部数据(in-house data)的实验，我们离线训练了4天的数据。并在随后一天的数据上执行评估。鉴于实际上只有一小部分曝光给用户的广告会被点击，数据标签不平衡构成了特别的挑战。在我们的训练设置中，**为了解决这种不平衡问题，负样本被下采样到原始数据集的5%，并且在loss函数中为负样本采用了更高的权重来解释这种修改**。经过这些步骤，训练数据的总数达到了6.68亿视频广告，而测试数据达到了700万广告。**对于评估数据集，如果在曝光时间之后的9小时内发生了消费，则给样本分配一个正标签。否则，样本被分配一个负标签**。随后，正例和负例都被下采样到它们原始大小的5%。

为了获得经过的时间和点击时间信息，在每个日期结束时对数据进行了快照捕捉。因此:

- 对于**尚未观察到消费的样本**：分配了一个负标签，并将从曝光时间到快照时间经过的时间作为特征添加。
- 对于**在快照时间之前观察到消费的样本**：除了经过的时间外，消费时间和曝光时间之间的差异被记录为点击时间。

**这些时间特征仅用于估计时间延迟模型**，这是延迟反馈损失（delayed feedback loss）所必需的。值得一提的是，由于大多数假负例（FN）已从这个派生的数据集中清除，正例/负例比例最终比以前更高。

### 4.2.3 在线Twitter数据

在在线实验中，所有模型都训练于实时生成的曝光回调数据的连续数据流。向用户展示广告曝光，并且每个样本的标签是根据当前的点击信息决定的（这就是假负例进入训练数据的地方）。然后，每个训练样本被发布到数据流中，模型的训练服务订阅了这个数据流。**连续训练过程每10分钟输出一次模型**，这些模型被预测服务获取以服务在线流量。在计算pooled RCE时，我们使用与生成离线评估数据相同的数据源，这意味着：**通过在给每个广告曝光分配标签之前等待9小时，我们才会移除假负例**。

需要注意的是，每个在线实验只服务于1%的生产流量，这意味着训练流量主要由我们当前的生产模型主导。我们还在这个参考生产流量上计算我们的在线这pooled RCE指标，这个流量不受任何模型的影响，以确保通过使用每个模型相同的评估数据集来保证公平性。


## 4.3 结果

### 4.3.1 离线评估

表2

在Twitter数据上的结果显示在表2和表3中，分别对应逻辑回归模型和Deep&Wide模型。这些对应于每个模型使用不同初始化进行的8次评估的中位性能。总体上，我们可以观察到，深度学习模型在所有loss函数上的表现都优于逻辑回归模型，这在预料之中。就RCE而言，


- logloss在两种模型中表现最差，而**FN校准损失为线性模型带来了最佳性能**（RCE为12.41，损失为0.5641）。
- PU loss和FN校准在深度模型上表现最佳，产生了几乎等效的结果（RCE分别为13.57和13.58），并且与FNW loss的性能非常相似（RCE为13.54）。因此，这三种损失函数与logloss在线上环境中进行了比较。

延迟反馈损失在两类模型中都优于logloss（线性模型的RCE分别为10.59和5.48，深度模型的RCE分别为12.11和7.81）。PR-AUC可能不像RCE那样变化大，但其在表现最佳的方法之间（使用非配对t检验在第1名和第2名方法之间）的差异仍然在统计上对线性模型显著。

### 4.3.2 在线评估

应该提到，以下结果对应于一个不考虑预算的实验，即在决定展示特定请求的广告时不考虑广告主的预算，该实验运行了1周。表4显示了使用Deep&Wide模型的顶级loss函数的在线结果。FN加权和FN校准与传统的logloss相比，都产生了更高的RPMq（分别增加了+55.10%和+54.37%）。同样地，对于货币化的CTR，增长也是显著的（FN加权为+23.01%，FN校准为23.19%）。我们观察到，尽管PU loss在离线表现良好，但在2天后出现分歧，并在分歧之前报告了在线指标。

附录：

- 1.[https://arxiv.org/pdf/2012.03245](https://arxiv.org/pdf/2012.03245)