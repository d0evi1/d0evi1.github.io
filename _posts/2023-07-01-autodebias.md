---
layout: post
title: auto debias介绍
description: 
modified: 2023-07-01
tags: 
---

ali在《AutoDebias: Learning to Debias for Recommendation》提出了一种autodebias的思想：

# 摘要

推荐系统依赖于用户行为数据（如评分和点击）来构建个性化模型。然而，收集到的数据是观测性而非实验性的，这导致了数据中的各种偏差，显著影响了学到的模型。大多数现有的推荐去偏差（debias）工作，如**逆概率评分（inverse propensity scoring）和插值法（imputation）**，仅专注于一两种特定的偏差，缺乏能够解释数据中混合甚至未知偏差的通用能力。

针对这一研究空白，我们首先从风险差异（risk discrepancy）的角度分析了偏差（bias）的来源，风险差异代表了期望经验风险和真实风险之间的差异。值得注意的是，我们推导出一个通用的学习框架，通过**指定通用框架的一些参数**，很好地总结了大多数现有的去偏差策略。这为开发通用的去偏差解决方案提供了宝贵的机会，例如通过从数据中学习去偏差参数。然而，训练数据缺乏关于数据如何有偏差以及无偏差数据是什么样子的的重要信号。为了推进这个想法，我们提出了AutoDebias，**它利用另一个（小的）均匀数据集，通过解决具有meta-learning的双层优化(bi-level optimization)问题来优化去偏差参数**。通过理论分析，我们推导出了AutoDebias的泛化界，并证明了其获得适当去偏差策略的能力。在两个真实数据集和一个模拟数据集上的大量实验证明了AutoDebias的有效性。

# 1.介绍

能够为每名用户提供个性化建议的推荐系统（RS）已在无数在线应用中得到广泛应用。近年来，关于推荐的出版物如雨后春笋般涌现，其中大多数旨在发明机器学习模型以拟合用户行为数据[17, 44, 52]。然而，在现实世界的RS中，这些模型的性能可能会下降，因为**行为数据通常充满偏差**。在实践中，数据是观测性的而非实验性的，并且经常受到许多因素的影响，包括但不限于：

- 用户的自我选择（选择偏差：selection bias）[19, 33]
- 系统的曝光机制（曝光偏差：exposure bias）[34, 47]
- 公众舆论（从众偏差：conformity bias）[25, 29]
- 展示位置（位置偏差：position bias）[22, 23]

这些偏差使数据偏离了反映用户真实喜好的状态。因此，如果不考虑数据偏差而盲目地拟合数据，将会产生意想不到的结果，例如放大**长尾效应（long-tail effect）[1]**和放大**之前模型偏差（previous-model bias）[28]**。

鉴于数据偏差的广泛存在及其对所学模型的巨大影响，我们无论如何强调实际RS中适当去偏差的重要性都不为过。现有的关于推荐（或学习排名）偏差的工作可以分为三大类：

- 1）数据填充(data imputation)[19, 42]，为缺失数据分配**伪标签**以减少方差；
- 2）逆概率评分（IPS）[39, 47]，一种反事实(counterfactual)技术，重新衡量收集到的数据以实现期望无偏学习；
- 3）生成式建模(generative modeling)[27]，假设数据的生成过程并相应地减少偏差。

尽管它们在某些场景中有效，但我们认为它们存在两个局限性：

- 缺乏普适性。这些方法是为解决**特定场景中的一种或两种偏差**而设计的，例如IPS用于选择偏差[39]，点击模型用于位置偏差[12]。因此，在面对通常包含多种类型偏差的真实数据时，这些方法将无法胜任。
- 缺乏自适应性。这些方法仅在**去偏差(debiasing)配置（例如伪标签、倾向得分或数据生成过程）得到正确指定的情况下**才有效。然而，获得这样的正确配置相当困难，需要深入了解数据中的偏差以及它们如何影响模型的领域专家。更糟糕的是，随着新用户/item/交叉的出现可能改变数据分布，最优配置可能会随时间演变，这已成为实践者**不断手动调整配置**的噩梦。

考虑到现有工作的不足，我们认为开发一种**通用的去偏差解决方案**至关重要，它不仅应考虑到多种偏差及其组合，还应解放人力来识别偏差和调整配置。为实现这一目标，我们首先回顾了常见的偏差和去偏差策略，得出了两个重要见解：

- （1）尽管不同偏差具有不同的来源和性质，但它们都可以被表述为**经验风险和真实风险之间的风险差异**，这是由于**收集训练数据所用的分布与用于无偏测试的分布不一致**所致；
- （2）最近大多数去偏差策略的成功可以归因于它们**为抵消模型训练中的差异**而采取的具体配置。

基于这些见解，我们提出了一个通过降低风险差异来概括大多数去偏差策略的通用去偏差框架——每种策略都可以通过指定框架的参数来恢复。这个框架为开发通用的推荐去偏差解决方案提供了一个宝贵的机会——我们可以通过学习框架的去偏差参数来进行自动去偏差。

现在的问题是如何优化去偏差参数。显然，有偏的训练数据缺乏关于数据如何有偏以及无偏数据是什么样子的的重要信号。为了解决这个问题，我们建议**利用另一个均匀数据(uniform data)来监督去偏差参数的学习**。假设均匀数据是通过随机logging policy[39]收集的，以无偏的方式反映用户偏好。我们充分利用了这一重要证据，通过**最小化均匀数据上的loss**来优化去偏差参数。具体而言，我们将这一过程表述为一个**双层优化（bi-level optimization）问题**，其中去偏差参数作为学习推荐模型的超参数，并通过元学习（meta-learning）技术[14]优化去偏差参数。我们对学习框架进行了理论分析，证明了：

- （1）在这种目标下学到的最优解近似于正确纠正偏差的最佳情况；
- （2）即使是在少量均匀数据上训练，它也能学到令人满意的去偏差策略。

最后，在利用均匀数据进行推荐方面，最相关的工作是最近提出的KDRec[28]。然而，我们认为它没有充分挖掘均匀数据的优势。**KDRec在均匀数据上训练一个单独的teacher模型，然后将模型的知识转移到有偏数据上的正常训练**。由于均匀数据是以降低用户体验为代价收集的，其规模通常相当小。因此，在其上训练的模型存在高方差，降低了KDRec的有效性。更重要的是，它缺乏理论保证，teacher模型如何抵消偏差的内在机制尚未完全理解。与KDRec相比，我们的框架以更具有理论依据的方式利用均匀数据，并在实证上取得了显著的改进。

总之，这项工作做出了以下主要贡献：

- 从风险差异的角度统一各种偏差，并开发了一个包含大多数去偏差策略的通用去偏差框架。
- 提出了一种利用均匀数据学习具有理论保证的最优去偏差策略的新方法。
- 在三种类型的数据（显式和隐式反馈，以及列表反馈的模拟数据）上进行实验，验证了我们提案的有效性。

# 2.预备知识 

在本节中，我们从风险差异的角度对推荐任务和各种偏差进行了阐述。

## 2.1 任务表述 

假设我们有一个包含user集U和item集I的推荐系统。

- 𝑢（或𝑖）：表示U（或I）中的用户（或item）
- $r \in R$: 表示用户对item给出的反馈（如评分值、点击量和停留时间）
- $D_T$：收集到的历史行为数据，可以表示为一个由未知分布$𝑝_T(u,i,r)$在user-item-label空间 $U×I×R$ 上生成的三元组集合$\lbrace (𝑢_𝑘, 𝑖_𝑘,𝑟_𝑘) \rbrace \mid 1≤𝑘 ≤ \mid 𝐷_𝑇 \mid$。

推荐系统的任务可以表述如下：从$𝐷_𝑇$中学习一个推荐模型，使其能够捕捉用户偏好并做出高质量的推荐。形式上，设：

- $𝛿 (.,.)$：表示预测值与真实标签之间的误差函数

推荐的目标是：从可用的数据集$𝐷_𝑇$中学习一个参数函数 $𝑓_\theta: U×I→R$，以最小化以下真实风险(true risk)：

$$
𝐿(𝑓)=E_{𝑝_𝑈(𝑢,𝑖,𝑟)} [𝛿(𝑓(𝑢,𝑖), 𝑟)]
$$

...(1) 
 
 其中：
 
 - $𝑓_𝜃$：可以由具有可学习参数𝜃的特定推荐模型实现。我们注意到，为了清晰表达，本文中的符号可能省略了子脚本“𝜃”。
 - $𝑝_𝑈 (𝑢,𝑖,𝑟)$：表示模型测试的理想无偏数据分布。该分布可以分解为user-item pair分布 $𝑝_𝑈 (𝑢,𝑖)$（通常假定为均匀分布）和每个user-item pair的事实偏好分布$𝑝_𝑈(𝑟 \mid 𝑢,𝑖)$
 
 由于真实风险不可访问，学习是通过优化以下经验风险(empirical risk)在训练集$𝐷_𝑇$上进行的：

$$
\widehat{𝐿}_𝑇(𝑓) = \frac{1}{|𝐷_𝑇|} \sum\limits_{k=1}^{|D_r|} 𝛿(𝑓(𝑢_𝑘, 𝑖_𝑘), 𝑟_𝑘)
$$

...(2)

 如果经验风险$\widehat{𝐿}_𝑇(𝑓)$是真实风险$𝐿(𝑓)$的无偏估计，即$E_{𝑝_𝑇}[𝐿_𝑇(𝑓)]=𝐿(𝑓)$，那么PAC学习理论[16]指出，如果有足够多的训练数据，我们学到的模型将接近最优。

## 2.2 推荐中的偏差 

然而，由于实际数据收集中存在各种偏差，训练数据分布$𝑝_𝑇$通常与理想的、无偏的分布$𝑝_𝑈$不一致。训练数据只能给出用户偏好的一种有偏差的快照，使得推荐模型陷入次优结果。图1说明了这种现象。红色曲线表示真实风险函数，而蓝色曲线表示有偏的经验风险函数的期望值$E_{𝑝_𝑇}[𝐿_𝑇(𝑓)]$。

...
图1

由于这两种风险是在不同的分布下预期的，因此即使在它们的最优点（即$𝑓^*$与$𝑓^𝑇$）处，它们的行为也会有很大差异。这意味着即使提供了足够大的训练集，并且模型达到了经验最优点$𝑓^𝑇$，仍然存在一个差距Δ𝐿，位于最优解$𝐿(𝑓^*)$和经验解$𝐿(𝑓^𝑇)$之间。

以上分析揭示了偏差对推荐的影响：**偏差(bias)会导致真实风险和预期经验风险之间的差异**。如果不考虑风险差异，盲目地拟合推荐模型将导致性能较差。最近的研究已经在推荐中识别出了各种偏差。在本小节中，我们将从风险差异的角度回顾这些偏差，以帮助读者更好地理解它们的性质和负面影响。我们参考[5]，并将数据偏差分为以下四类：

- **选择偏差(Selection bias)**：发生在用户可以自由选择给哪些item评分时，因此**观察到的评分不是所有评分的代表性样本[5]**。从风险差异的角度可以很容易地理解选择偏差——它使实际的user-item pair分布$𝑝_𝑇(𝑢,𝑖)$偏离了理想的均匀分布$𝑝_𝑈(𝑢,𝑖)$。**通常，$𝑝_𝑇(𝑢,𝑖)$倾向于评级值较高的pair**。在这样的有偏数据下学习推荐模型，很容易高估用户对物品的偏好。

- **从众偏差（Conformity bias）**：发生在用户倾向于与群体中的其他人行为相似，即使这样做违背了自己的判断[5]。从众偏差扭曲了标签分布$𝑝_𝑇(𝑟 \mid 𝑢,𝑖)$，使其符合公众意见，使得反馈并不总是代表用户的真实偏好，即$𝑝_𝑇(𝑟 \mid 𝑢,𝑖) \neq 𝑝_𝑈(𝑟 \mid 𝑢,𝑖)$。

- **曝光偏差（Exposure bias）**：发生在隐式反馈数据中，因为**用户只接触到特定item的一部分[5]**。从上述定义中可能很难理解曝光偏差，但从风险差异的角度来看就很直观。一方面，用户在接触到的item上产生行为，使得观察到的user-item分布$𝑝_𝑇(𝑢,𝑖)$偏离了理想分布$𝑝_𝑈(𝑢,𝑖)$。另一方面，隐式反馈数据只有正反馈被观察到$𝑝_𝑇(𝑟=1 \mid 𝑢,𝑖)=1$。**这种只有正的数据会导致未观察到的交互的解释产生歧义——它们可能是由于未曝光或者不喜欢造成的**。

- **位置偏差（Position bias）**：发生在用户倾向于与推荐列表中较高位置的item进行交互时[5]。在位置偏差下，训练数据分布$𝑝_𝑇(𝑢,𝑖,𝑟)$将对item显示位置敏感，无法忠实地反映用户偏好。一方面，排序位置将影响item展示给用户的机会[34]，即$𝑝_𝑇(𝑢,𝑖) \neq 𝑝_𝑈(𝑢,𝑖)$。另一方面，由于用户通常信任推荐系统，他们的判断也会受到位置的影响，即$𝑝_𝑇(𝑟 \mid 𝑢,𝑖) ≠ 𝑝_𝑈(𝑟 \mid 𝑢,𝑖)$。一般来说，上述偏差可以归纳为一种风险差异——它们导致训练数据分布$𝑝_𝑇(𝑢,𝑖,𝑟)$偏离理想的、无偏的分布$𝑝_𝑈(𝑢,𝑖,𝑟)$。这种洞察促使我们开发一个强大的框架，直接克服风险差异，实现对数据中混合的上述偏差甚至未知偏差的消除。

# 3.通用去偏差框架 

在本节中，我们提供了一个通用的去偏差框架，可以处理推荐数据中的各种偏差。然后，我们讨论它如何包含大多数现有的去偏差策略。

## 3.1 去偏差经验风险 

第2.2节中的分析表明，各种偏差导致了风险差异。为了实现无偏学习，我们需要重新设计经验风险函数，使其在带有偏差的训练分布下的期望与真实风险一致。通过比较$𝐿(𝑓)$和$E_{𝑝_𝑇}[\widehat{𝐿}_𝑇(𝑓)]$，我们可以看到差异源于数据分布，其中每个数据点在经验风险中的作用已经发生偏斜。为了解决这个问题，我们可以对训练数据进行重新加权，得到一个加权的经验风险函数：

$$
\widehat{𝐿}_𝑇(𝑓|𝑤(1)) = \frac{1}{|𝐷_𝑇|} * \sum\limits_{𝑘=1}^{|𝐷_𝑇|} 𝑤(1)^𝑘 * 𝐿(𝑓(𝑢_𝑘,𝑖_𝑘), 𝑟_𝑘)
$$ 

...(3)

当参数$𝑤(1)$被正确指定时，即$𝑤(1)^𝑘 =\frac{𝑝_𝑈(𝑢_𝑘,𝑖_𝑘,𝑟_𝑘)} {𝑝_𝑇(𝑢_𝑘,𝑖_𝑘,𝑟_𝑘)}$，每个采样的训练数据的偏度都被纠正了。这样的经验风险$\widehat{𝐿}_𝑇(𝑓 \mid 𝑤(1))$似乎是真实风险的无偏估计，因为：

$$
𝐸_{𝑝_𝑇}[\widehat{𝐿}_𝑇(𝑓|𝑤(1))] = 𝑆_1 \in 𝑆(𝑢,𝑖,𝑟) 𝑝_𝑈(𝑢,𝑖,𝑟) 𝛿(𝑓(𝑢,𝑖), 𝑟)
$$
 
 ... (4) 
 
 其中：
 
 - 𝑆1:表示满足$𝑝_𝑇(𝑢,𝑖,𝑟) > 0$且$𝑝_𝑈(𝑢,𝑖,𝑟) > 0$的user-item-label子空间，即：$𝑆1 ≡ \lbrace(𝑢,𝑖,𝑟) \in U × I × R : 𝑝𝑇(𝑢,𝑖, 𝑟) > 0, 𝑝𝑈(𝑢,𝑖, 𝑟) > 0 \rbrace$。
 
 然而，$E_{𝑝_𝑇}[\widehat{𝐿}_𝑇(𝑓 \mid 𝑤(1))]$与$𝐿(𝑓)$实际上并不相等。如图2所示，训练数据分布$𝑝_𝑇$仅覆盖了$𝑝_𝑈$支持的一部分区域（即$𝑆_1$），而在其他区域（$𝑆0 ≡ \lbrace(𝑢,𝑖, 𝑟) ∈ 𝑈 × 𝐼 × 𝑅 : 𝑝𝑇(𝑢,𝑖, 𝑘) = 0, 𝑝𝑈(𝑢,𝑖, 𝑘) > 0 \rbrace$）没有概率。这意味着即使有足够多的训练数据可用，它仍然只提供部分user-item pair，而忽略了其余部分。当$𝑆_0$和$𝑆_1$表现出不同的模式时，仅在$𝑆_1$上学习会受到特别大的影响。这种情况在实践中很常见：系统倾向于展示热门item[24]，而相当多的冷门item几乎没有机会被展示。为了解决这个问题，我们需要向空白区域填充伪数据。实际上，𝐿(𝑓)的等效变换是： 
 
 $$
 𝐿(𝑓) = 𝑆1∈𝑆(𝑢,𝑖,𝑟) 𝑝𝑈(𝑢,𝑖, 𝑟)𝛿(𝑓(𝑢,𝑖), 𝑟) + 𝑆0∈𝑆(𝑢,𝑖,𝑟) 𝑝𝑈(𝑢,𝑖, 𝑟)𝛿(𝑓(𝑢,𝑖), 𝑟) = 𝐸𝑝𝑇[1 / |𝐷𝑇| * ∑𝑘=1^|𝐷𝑇| 𝑤(1)^𝑘 * 𝛿(𝑓(𝑢𝑘,𝑖𝑘), 𝑟𝑘)] + 𝑆𝑢∈U,𝑖 ∈I 𝑤(2)^𝑢𝑖 * 𝛿(𝑓(𝑢,𝑖),𝑚𝑢𝑖)
 $$
 
 ...(5) 
 
 当参数𝜙 ≡ {𝑤(1),𝑤(2),𝑚}设置为： 
 
 𝑤(1)^𝑘 = 𝑝𝑈(𝑢𝑘,𝑖𝑘, 𝑟𝑘) / 𝑝𝑇(𝑢𝑘,𝑖𝑘, 𝑟𝑘) 𝑤(2)^𝑢𝑖 = 𝑆𝑟 ∈R 𝑝𝑈(𝑢,𝑖, 𝑟)I[𝑝𝑇(𝑢,𝑖, 𝑟) = 0] 𝑚𝑢𝑖 = 𝐸𝑝𝑈(𝑟 |𝑢,𝑖)[𝑟I[𝑝𝑇(𝑢,𝑖, 𝑟) = 0]]，(6) 
 
 则等式成立。

在这个上下文中，"where I[.] denotes indicator function"表示I[.]是一个指示函数。在这里，我们将𝛿(., .)的期望吸收到伪标签中，即E[𝛿(., .)] = 𝛿(., E[.])。这适用于许多常用的损失函数，如L2、L1和交叉熵。因此，我们定义以下经验风险函数：

𝐿ˆ𝑇(𝑓|𝜙) =
1
|𝐷𝑇|
|
Õ
𝐷𝑇|
𝑘=1
𝑤(1)
𝑘
𝛿(𝑓(𝑢𝑘,𝑖𝑘), 𝑟𝑘) + Õ
𝑢∈U,𝑖 ∈I
𝑤(2)
𝑢𝑖 𝛿(𝑓(𝑢,𝑖),𝑚𝑢𝑖),
(7)

当参数正确指定时，这是真实风险的无偏估计器。我们注意到可能存在多个𝜙的解，但至少有一个（即方程（6））使得方程𝐿ˆ𝑇(𝑓|𝜙) = 𝐿(𝑓)成立。这个通用的经验风险函数为实现自动去偏差提供了一个宝贵的机会——通过学习去偏差参数𝜙来实现。

3.2 与相关工作的联系
为了展示我们框架的广泛性，我们回顾了代表性的去偏差策略，并讨论了框架如何包含它们。

选择偏差。现有的方法主要有三种类型：
(1) 逆概率得分（IPS）[39]对收集到的数据进行重新加权以实现无偏学习，定义经验风险为：
Lˆ𝐼𝑃𝑆(𝑓) =
1
|U||I|
|
Õ
𝐷𝑇|
𝑘=1
1
𝑞𝑢𝑘𝑖𝑘
𝛿(𝑓(𝑢𝑘,𝑖𝑘), 𝑟𝑘), (8)
其中𝑞𝑢𝑘𝑖𝑘定义为倾向，用于估计数据被观察到的概率。通过设置𝑤(1)𝑘 = |𝐷𝑇|𝑞𝑢𝑘𝑖𝑘|U| |I|，𝑤(2)𝑘 = 0，框架可以恢复它。

(2) 数据插补[19]为缺失数据分配伪标签，并优化以下风险函数：
𝐿ˆ𝐼𝑀(𝑓) =
1
|U||I|
(
|
Õ
𝐷𝑇|
𝑘=1
𝛿(𝑓(𝑢𝑘,𝑖𝑘), 𝑟𝑘) + Õ
𝑢∈U,𝑖 ∈I
𝜆𝛿(𝑓(𝑢,𝑖),𝑚𝑢𝑖), (9)
其中𝑚𝑢𝑖表示插补的标签，可以通过启发式方法[21]或专用模型[7, 32, 37]进行指定。𝜆用于控制插补数据的贡献。如果设置𝑤(1)𝑘 = |𝐷𝑇||U| |I|，𝑤(2)𝑢𝑖 = 𝜆|U| |I|，它就是框架的一个特例。

(3) 双重稳健性[48]将上述模型结合起来以获得更高的鲁棒性——即如果插补数据或倾向中的任何一个准确，都能保持无偏性。它优化了以下风险函数：
𝐿ˆ𝐷𝑅(𝑓) =
1
|U||I|
Õ
𝑢∈|U|,𝑖 ∈|I|

𝛿(𝑓(𝑢,𝑖),𝑚𝑢𝑖) + 𝑂𝑢𝑖𝑑𝑢𝑖
𝑞𝑢𝑖 
, (10)

其中 𝑑𝑢𝑖 = 𝛿 (𝑓 (𝑢,𝑖), 𝑟𝑜 𝑢𝑖) − 𝛿 (𝑓 (𝑢,𝑖), 𝑟𝑖 𝑢𝑖) 表示预测误差与插补误差之间的差异。𝑟 𝑜 𝑢𝑖 表示观察到的评分值。𝑂𝑢𝑖 表示（𝑢,𝑖）交互是否被观察到。我们的框架可以通过设置 𝑤 (1) 𝑘
|𝐷𝑇 | 𝑞𝑢𝑘 𝑖𝑘 |U | |I | , 𝑤 (2) 𝑢𝑖 = 1 |U | |I | − 𝑂𝑢𝑖 𝑞𝑢𝑖 |U | |I | 来恢复这个值。从众偏差。从众效应可以通过优化 [29, 31] 来抵消： 𝐿ˆ𝑂𝐹 𝐹 (𝑓 ) = 1 |𝐷𝑇 | | Õ 𝐷𝑇 | 𝑘=1 (𝛼𝑟𝑘 + (1 − 𝛼)𝑏𝑢𝑘𝑖𝑘 − 𝑓 (𝑢𝑘 ,𝑖𝑘 ))2 , (11) 其中 𝑏𝑢𝑘𝑖𝑘 表示引入的偏差项，可以将其指定为所有用户的平均评分[29]或社交朋友[31]。𝛼 控制从众效应的影响。我们的框架通过设置 𝑤 (1) 𝑘 = 1,𝑤 (2) 𝑢𝑖 = 𝑂𝑢𝑖(1 − 𝜆),𝑚𝑢𝑖 = −𝑏𝑢𝑖 来包含它。曝光偏差。现有的方法主要有两种类型： (1) 负加权，将未观察到的交互视为负数并降低它们的贡献 [21]： 𝐿ˆ𝑁𝑊 (𝑓 ) = 1 |𝐷𝑇 | | Õ 𝐷𝑇 | 𝑘=1 𝛿 (𝑓 (𝑢𝑘 ,𝑖𝑘 ), 𝑟𝑘 ) + Õ (𝑢,𝑖) ∈U×I:𝑂𝑢𝑖=0 𝑎𝑢𝑖𝛿 (𝑓 (𝑢,𝑖), 0), (12) 其中参数 𝑎𝑢𝑖 表示项目被用户接触的可能性，可以用启发式方法指定[21]或者通过曝光模型[6, 9, 27]指定。我们可以通过设置 𝑤 (1) 𝑘 = 1, 𝑤 (2) 𝑢𝑖 = 𝑎𝑢𝑖(1 − 𝑂𝑢𝑖), 𝑚𝑢𝑖 = 0 来恢复这种方法。 (2) IPS 变体，重新权衡观察到的数据并插补缺失的数据 [38]： 𝐿ˆ 𝐼𝑃𝑆𝑉 (𝑓 ) = | Õ 𝐷𝑇 | 𝑘=1 1 𝑞𝑢𝑘𝑖𝑘 𝛿 (𝑓 (𝑢𝑘 ,𝑖𝑘 ), 𝑟𝑘 ) + Õ 𝑢∈U,𝑖 ∈I (1 − 𝑂𝑢𝑖 𝑞𝑢𝑖 )𝛿 (𝑓 (𝑢,𝑖), 0)。 (13)

我们可以通过设置 𝑤 (1) 𝑘
|𝐷𝑇 | 𝑞ˆ𝑢𝑘 𝑖𝑘 |U | |I | , 𝑤 (2) 𝑢𝑖 = 1 |U | |I | − 𝑂𝑢𝑖 𝑞𝑢𝑖 |U | |I | , 𝑚𝑢𝑖 = 0 来恢复它。值得一提的是，Variant IPS 的无偏性条件是训练分布 𝑝𝑇 覆盖了 𝑝𝑈 的整个支撑集，然而这在实践中很少成立。位置偏差。最流行的策略是 IPS [3]，它使用一个位置感知分数 𝑞ˆ𝑡𝑘 对收集到的数据进行重新加权： 𝐿ˆ 𝐼𝑃𝑆 (𝑓 ) = 1 |𝐷𝑇 | | Õ 𝐷𝑇 | 𝑘=1 𝛿 (𝑓 (𝑢𝑘 ,𝑖𝑘 ), 𝑟𝑘 ) 𝑞𝑡𝑘 。 (14) 可以通过设置 𝑤 (1) 𝑘
1 𝑞𝑡𝑘 , 𝑤 (2) 𝑢𝑖 = 0 来恢复它。

# 4.自动去偏差(AutoDebias)算法 

我们现在考虑如何优化上述框架。由于训练数据缺乏关于数据如何偏差以及无偏差数据是什么样子的的重要信号，因此无法从这样的数据中学习到适当的去偏差参数。为了解决这个问题，我们引入了另一个**均匀数据$𝐷_𝑈$**来监督去偏差参数的学习。均匀数据包含一系列三元组 $\lbrace(𝑢_𝑙 ,𝑖_𝑙 , 𝑟_𝑙) \rbrace \mid 1≤𝑙≤\mid 𝐷_𝑈 \mid$ ，假设这些数据是**通过随机logging policy收集**的，为无偏推荐性能提供了黄金标准证据。我们充分利用这一证据，优化𝜙以便在均匀数据上获得更好的性能。具体而言，学习过程可以表示为一个元学习过程，包括：


## 4.1 base learner

基于当前的**去偏差参数𝜙**，在训练数据上优化base推荐模型：

$$
\theta^*(𝜙) = \underset{𝜃}{argmin} \  \widehat{𝐿}_𝑇(𝑓_\theta |𝜙)
$$ 

...(15) 

其中:

- debias参数 𝜙 可以被视为base learner的超参数。 

## 4.2 meta learner

给定通过超参数𝜙，从训练数据中学到的base推荐模型 $𝜃^*(𝜙)$，在均匀数据上优化 𝜙 以便获得更好的推荐效果：

$$
𝜙^* = \underset{\phi}{argmin} \ \frac{1}{|𝐷_𝑈|} \sum\limits_{𝑙=1}^{|D_U|} \sigma(𝑓_{𝜃^*(𝜙)} (𝑢_𝑙 ,𝑖_𝑙), 𝑟_𝑙)
$$

... (16) 

为了更好地描述，我们将均匀数据上的经验风险(empirical risk )标记为： $\widehat{𝐿}_𝑈(𝑓_𝜃)$，即 $\widehat{𝐿}_𝑈 (𝑓_𝜃)= \frac{1}{|𝐷_𝑈|} \sum\limits_{𝑙=1}^{|𝐷_𝑈|} 𝛿(𝑓_𝜃(𝑢_𝑙,𝑖_𝑙), 𝑟_𝑙)$。

**由于均匀数据通常是小规模收集的，直接从其中学习𝜙中的所有参数会导致过拟合**。为了解决这个问题，可以使用简洁的元模型（meta model）对𝜙进行重新参数化。这种处理可以减少参数的数量，并将有用的信息（例如，用户ID、观察到的反馈）编码到debias中。在本文中，我们简单地选择线性模型(linear model)进行实现，如下所示： 

$$
𝑤_𝑘^{(1)} = exp(𝜑_1^𝑇 [x_{𝑢_𝑘} \circ x_{𝑖_𝑘} \circ e_{𝑟_𝑘}]) \\
𝑤_{ui}^{(2)} = exp(𝜑_2^T [x_𝑢 \circ x_𝑖 \circ e_{𝑂_{𝑢𝑖}}]) \\
𝑚_{𝑢𝑖}=\sigma(𝜑_3^T [e_{𝑟_{𝑢𝑖}} \circ e_{𝑂_{𝑢𝑖}} ])
$$

...(17) 

其中:

- $x_𝑢$ 和 $x_𝑖$：分别表示用户𝑢和物品𝑖的特征向量（例如，其ID的一维向量）；
- $e_𝑟、e_{𝑂_{𝑢𝑖}} $：是 𝑟 和 $𝑂_{𝑢𝑖}$ 的一维向量；
- $\circ$：表示连接操作；
- $𝜑 ≡ {𝜑_1, 𝜑_2, 𝜑_3}$ 是待学习的代理参数；
- $\sigma(\cdot)$表示激活函数，用于控制插补值的比例，例如 $𝑡𝑎𝑛ℎ(\cdot)$

有人可能会担心，使用元模型对 𝜙 进行建模可能会引入归纳偏差，限制 𝜙 的灵活性，使其无法达到全局最优。实际上，我们的框架对这种归纳偏差相对稳健，这一点已在第5节中得到验证。 

**模型学习**

请注意，获得最优$𝜙^∗$涉及到嵌套的优化循环——向前更新𝜙一步需要完整训练𝜃的一个循环，这是昂贵的。为了解决这个问题，我们考虑在循环中交替更新𝜃和𝜙。也就是说，对于每个训练迭代，我们使用当前的𝜙对推荐模型进行尝试性更新，并在均匀数据上检查其性能。均匀数据上的损失将给出反馈信号以更新元模型。确切地说，如图3所示，我们在每次迭代中执行以下训练过程： 

• 假设𝜃更新。如图3中的黑色箭头所示，我们对𝜃进行假设性更新：

$$
𝜃′(𝜙) = 𝜃 − \eta_1 \nabla_{\theta} \widehat{𝐿}_𝑇(𝑓_{\theta} | \phi)
$$

...(18)

我们使用学习率为$\eta_1$的梯度下降法更新𝜃。

• $𝜙(𝜑)$的更新。如图3中的蓝色箭头所示，我们在具有$\widehat{𝐿}_𝑈$的一致性数据上测试$𝜃′(𝜙)$。loss函数给出一个反馈信号（梯度）来更新元模型𝜑：

$$
𝜑 ← 𝜑 − 𝜂_2 \nabla_{𝜑} \widehat{𝐿}_𝑈(𝑓_{𝜃′(𝜙)})
$$

...(19) 

可以通过沿着链 $\widehat{𝐿}_𝑈(𝑓_{\theta'}(\phi)) \rightarrow \theta'(\phi) \rightarrow \nable_{\theta} \widehat{𝐿}_𝑇(𝑓_{\theta} \mid \phi)) \rightarrow \phi \rightarrow \varphi$ 反向传播来计算梯度。

• 𝜃的更新。给定更新的𝜙，我们实际上更新$\theta$如下:

$$
\theta \leftarrow \theta − \eta_1 \nabla_{\theta} \widehat{𝐿}_𝑇(𝑓_{\theta} | \phi))
$$

...(20) 

虽然这种替代优化策略不能保证找到全局最优解，但它在经验上很好地解决了双层优化问题[14]。


[https://dl.acm.org/doi/pdf/10.1145/3404835.3462919](https://dl.acm.org/doi/pdf/10.1145/3404835.3462919)

