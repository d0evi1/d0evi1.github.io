---
layout: post
title: word2vec中的logistic回归
description: 
modified: 2016-01-10
tags: [word2vec]
---

# 介绍

word2vec中的logistic function计算使用的是快速算法，初始先算好值，然后在神经网络训练迭代中直接查表加快计算和训练速度。设计也还算精巧。

# 代码

在初始化时，有代码片段一，会对expTable做专门的初始化：

{% highlight c %}

#define EXP_TABLE_SIZE 1000
#define MAX_EXP 6



// step 4: 分配logistic查表.
expTable = (real *)malloc((EXP_TABLE_SIZE + 1) * sizeof(real));
  
// 初始化: 预先计算好指数运算表. 
for (i = 0; i < EXP_TABLE_SIZE; i++) {
    expTable[i] = exp((i / (real)EXP_TABLE_SIZE * 2 - 1) * MAX_EXP); // Precompute the exp() table
    expTable[i] = expTable[i] / (expTable[i] + 1);                   // Precompute f(x) = x / (x + 1)
  }


{% endhighlight %}

expTable数据的大小为1000，存了1000个值用于查表。

而在模型训练阶段，代码片段二：

{% highlight c %}


// 前向传播: f=∑ neu1*syn1
// Propagate hidden -> output
for (c = 0; c < layer1_size; c++) {
  f += neu1[c] * syn1[c + l2];
}

// 范围判断，查表
if (f <= -MAX_EXP) 
  continue;
else if (f >= MAX_EXP) 
  continue;
else 
  f = expTable[(int)((f + MAX_EXP) * (EXP_TABLE_SIZE / MAX_EXP / 2))];

{% endhighlight %}

将代码片段二代入到代码片段一，我们可以发现很神奇的现象：

将上式简单做个替换：

<img src="http://pic.yupoo.com/wangdren23/G80PsTFz/medish.jpg">

而再做一次运算，即知该表的值刚好与 logit函数 y = 1/(1+e^-z) 相同。

# 为什么要这么设计呢？

通过查表法，当然是为了加快指数运算。如果在每次迭代时，都去做指数运算，cpu开销蛮大。这样的设计，可以优化训练时间。

我来来看前前一段代码中，expTable[0 ... EXP_TABLE_SIZE]中具体对应的值是哪些？这里，我提供了它的python实现：[代码下载](https://github.com/d0evi1/word2vec_insight/blob/master/exptable.py) ，绘制出实际的取值曲线（logistic regression的某一段取值），横坐标[0,1000]，纵坐标[0,1]的取值空间：

<img src="http://pic.yupoo.com/wangdren23/G8xdMdLK/medish.jpg">


另外，还有一点，就是这样的分割：EXP_TABLE_SIZE=1000， MAX_EXP=6？ 把数字代入，即知：

<img src="http://www.forkosh.com/mathtex.cgi?e^(\frac{2*i}{1000}-1)*6)">

<img src="http://www.forkosh.com/mathtex.cgi?i=\frac{(f+6)*(1000)}{6*2}">

为什么要做这样的trick进行分解呢？上图展示的是从输入z的角度去理解。要真正理解为什么这样取，还要结合实际代码中Hierarchical softmax代码里的情况去理解。

里面的f输入范围在(-MAX_EXP, MAX_EXP), 即(-6, 6)。

(f + MAX_EXP)/MAX_EXP/2 做的操作，将该输入进行转换，并归一化到(0,1)范围内。然后再乘以EXP_TABLE_SIZE，即是第一式的输入i。

现在，我们可以抛出另一个疑问：为什么要设置MAX_EXP，或者说，为什么要限制f的范围？

因为expTable的size只有EXP_TABLE_SIZE这么大，如果大于MAP_EXP，或者小于MAX_EXP，就相当于超出了expTable的索引范围。因此，那些f值超过(-MAX_EXP,MAX_EXP)范围的，都将被抛弃掉。

看到这里还是一团疑惑，可能还是不明白，为什么要做这样的查表设计。

我们不防从输入为f的角度，把曲线重新绘制一遍：
















