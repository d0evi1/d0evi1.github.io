---
layout: post
title: pinterest的交叉实践
description: 
modified: 2023-12-5
tags: 
---

pinterest在《Improving feature interactions at Pinterest under industry
constraints》提出了一种特征交叉的新思路。

# 摘要

在工业环境中采用推荐系统的先进成果常常面临挑战，因为存在独特的约束条件。本文旨在通过特征交互的视角**来突出这些约束**。特征交互对于准确预测推荐系统和在线广告中的用户行为至关重要。尽管许多新颖的技术在Criteo等基准数据集上显示出优越的性能，但由于模型延迟、GPU内存限制和模型可复制性等约束，它们的直接应用在工业环境中受到阻碍。在本文中，我们分享了在这些约束下改进Pinterest首页排序模型中特征交互的经验。我们提供了遇到的特定挑战、为解决这些挑战而采取的策略以及为平衡性能与实际限制所做的权衡的详细信息。此外，我们展示了一组学习实验，这些实验有助于指导特征交互架构的选择。我们相信这些见解对于有兴趣通过更好的特征交互学习来改进模型的工程师将是有用的。

# 1 引言

Pinterest是最大的内容分享平台之一，拥有超过5亿的月活跃用户[9]。如图1所示的Homefeed是大多数用户的首要入口点，也是主要的灵感来源，占据了平台上用户参与度的大部分。Pinterest上的用户可以通过保存、放大、隐藏等多样的操作与Pin进行互动。

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/ee64a47ef8e25207fb236e747e2b8fde3600943983fc5488a1f4da820f4894fd4473c6c50d3d1c8d0c5697f118294525?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;fname=1.jpg&amp;size=750">

图1

为了增强用户在Homefeed上的体验，我们使用推荐系统确保为用户提供最相关的Pin。我们使用的是基于标准的检索、排名和混合的推荐系统。排序模型负责预测不同用户行为的概率。这是通过多任务建模方法实现的。

我们的排序模型可以分为三个部分：特征预处理、特征交互和任务预测。特征交互是模型的关键部分，对于有效捕捉特征和标签之间的复杂关系至关重要。

近年来[11][14][8][17]，提出了许多架构来高效学习这些关系。然而，这些架构通常在基准数据集的离线设置中进行评估，并没有考虑到工业推荐系统面临的现实世界约束。过多的超参数和高内存使用等限制使得这些技术在工业环境中不切实际。应对这些约束是改进我们的模型并为用户提供价值的关键。

本文的核心贡献总结如下：
- 我们详细描述了工业环境中面临的约束，并将其与学术研究进行对比。
- 我们提出了一组学习实验，以帮助指导选择合适的交互架构和超参数。
- 我们分享了在这些特定行业约束下，通过学习实验改进排序模型中特征交互的经验。
本文的其余部分组织如下：第2节回顾相关工作。第3节描述了Homefeed排序模型。我们在第4节详细说明了我们工作的约束。第5节报告了使用不同特征交互层的学习实验和实验结果。最后，我们在第6节总结我们的工作。

# 2 相关工作

当今大多数工业推荐系统都基于深度神经网络模型，这些模型的大部分关键部分是有效地学习特征交互。像Wide & Deep[1]和DeepFM[5]这样的架构表明，学习低阶和高阶特征交互是有用的。[2]显示，随着更好的特征交互架构的出现，Criteo数据集上的点击率预测逐年变得更好。
多层感知机（MLP）允许隐式建模高阶特征交互。DCN[12]及其后继者DCNv2[13]增加了一个显式的特征交叉来学习更好的交互。同样，xDeepFM[7]使用压缩交互网络（CIN）以显式方式学习低阶和高阶特征交互。AutoInt[10]提出了一个基于注意力的机制，在低维空间中显式建模特征交互。

Masknet[14]使用实例引导的掩码来辅助交互学习。FinalMLP[8]表明，一个经过良好调整的双流MLP模型可以胜过显式交叉。GDCN[11]使用门控来过滤掉嘈杂的特征交互，允许更高阶的特征交互。DHEN[16]提出了一个结合多种特征交互的框架。SDCNv3[6]提出使用浅层和深层交叉网络，整合了低阶和高阶特征交互。尽管这些新架构提高了准确性，但它们增加了模型的延迟和内存消耗，这使得在工业环境中更难使用。

DeepLight[3]提出通过使用一种机制来剪枝神经网络，以减少推理时间同时保持模型性能，从而缓解这个问题。然而，剪枝引入了失去可复制性的风险，这在工业环境中很重要。使用多头注意力机制的Transformer架构已被证明在特征交互学习方面是有效的[4]。


# 3 首页feeds排序模型（HOMEFEED RANKING MODEL）

Homefeed排序模型是一个深度学习模型，负责预测用户参与度概率的点估计。给定一个用户  u 和一个Pin  p，模型预测  K 个概率——每个我们关心的用户行为（如保存、放大、隐藏等）都有一个。我们使用dense特征、sparse特征和嵌入特征的组合来表示用户、Pin和上下文。

- dense特征被标准化以确保数值稳定性。
- 我们使用可学习的嵌入来表示sparse特征，并根据特征的基数选择嵌入大小。我们将较大的嵌入特征投影到较小的维度，然后再输入到模型中。
- 最重要的嵌入特征之一是我们的用户序列嵌入。它是使用基于Transformer的架构[15]学习得到的，输入是用户过去的参与情况。这个Transformer的输出被汇总到一个嵌入特征中

。稀疏和嵌入特征在与dense特征连接成一个单一特征嵌入之前被**L2标准化**。这个特征嵌入被用作特征交互层的输入。我们使用4个堆叠的全秩DCNv2[13]层来模拟特征交互。我们在将交叉特征嵌入和输入特征嵌入连接后，再传递到MLP层。我们使用一个共享的MLP，它有多个隐藏层，并预测对应于K个任务的K个输出。模型是使用用户过去的参与数据进行训练的，使用**加权交叉熵损失。损失中的权重是根据业务需求选择的**。我们将图2a中显示的架构作为我们所有实验的基线。

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/cc607262ecb16396b50b22d0cf89f236db0f3165b9cfeb6380de38c397ffdfe6382404ecdb3e3405a5891c5eb0af2646?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;fname=2.jpg&amp;size=750">

图2 Homefeed ranking model

# 4 约束（CONSTRAINTS）

在迭代工业推荐系统时，考虑排序模型的各种约束至关重要。以下是其中一些约束，特别关注与我们的特征交互实验相关的，并与学术界进行对比。这不是一个详尽的列表，因为它不包括其他重要的考虑因素，如多样性和平衡业务指标。

## 4.1 内存

为了有效地利用我们的计算资源，**我们选择的模型训练batch大小使得模型训练期间分配的最大内存大约是总可用内存的60%**。这种分配为系统内存、内存碎片和可能增加内存使用的潜在未来项目留出了空间。尽管我们观察到进一步增加这个比例可以提高我们的模型质量，但如果最大分配内存超过75%，我们在模型重新训练期间会遇到间歇性的内存不足（OOM）错误。为了缓解这个问题，我们可以减少batch大小，但这是以牺牲模型质量和引入实验中的混杂变量为代价的。因此，任何需要大量额外内存的新技术都必须显著提高模型质量，以抵消因减少batch大小而造成的损失。

这通常不是学术研究的考虑因素，在那里batch大小可能被调整以最大化目标指标和训练时间。

## 4.2 延迟

模型推理延迟是我们整体系统延迟的重要组成部分。**任何这种延迟的增加都会降低我们分布式服务系统的吞吐量**。因此，我们然后需要**增加额外的机器**以获得相同的服务吞吐量，导致更高的运营成本。必须确保模型的任何改进都证明这些额外成本是合理的。此外，增加的模型延迟可以延长训练时间，从而影响开发速度。

在学术研究中，**5%的延迟增加可能不会有关键影响，但在工业应用中，它会显著增加服务成本**。话虽如此，由于可以轻松获得额外的计算资源，这是最容易权衡的约束之一。

## 4.3 超参数

使用具有众多超参数的模型架构会增加需要训练的模型数量，以确定最优配置。随着我们用户兴趣的变化，我们的数据分布也在变化。这要求我们**定期调整这些超参数**，以优化模型以适应最新的数据分布。

学术论文通常会进行广泛的超参数调整，以确定表现最佳的变体。由于这是一次性成本，减少模型中的超参数数量通常不是考虑因素。

## 4.4 可复制性

确保我们的模型可以使用相同的数据重新训练并**产生一致的结果**至关重要。没有这种一致性，就很难确定观察到的指标变化是给定变化的真实改进，还是模型内的简单变化。因此，任何纳入模型的特征交互都不应降低其可复制性。

我们通过计算使用相同配置的运行中**HIT@3/save指标**的标准差来衡量可复制性。一个可复制的模型应该有低标准差。

在学术界，可复制性不是一个重要因素。指标通常被报告为使用相同配置的几次运行的指标均值，但标准差通常不被比较。

## 4.5 稳定性

我们使用分布式训练方法来训练我们的模型，其中数值不稳定性可能导致模型失败。这要求我们从之前的检查点重新开始或完全放弃运行，导致计算资源浪费。任何纳入模型的新特征交互都不应影响其稳定性。

由于我们不断在新数据上重新训练我们的模型，跨不同数据分布的稳定性很重要。学术界通常使用固定的基准数据集来报告指标，所以通常不跟踪稳定性。

# 5 实验

## 5.1 指标

我们使用以下指标来评估我们的模型：

- **HIT@3/save指标[15]**：尽管我们的模型预测多种行为，我们使用最重要的动作——保存（save），来进行模型的离线评估。我们根据新的预测结果对每个用户会话记录的结果进行排序，并计算前3个Pin中的保存(save)量。我们将这个指标与基线模型进行比较，并以百分比增益或损失的形式报告。
- **内存**：这是训练期间分配的峰值内存，作为总可用GPU内存的百分比。
- **延迟**：这是与基线模型相比，在大量batch中模型推理时间的增加或减少。

## 5.2 学习实验
在本节中，我们展示了我们进行的一系列学习实验，以确定哪些架构更改对模型有益。这些学习实验的结果在表1中。


表1

### 5.2.1 交互的顺序

我们评估了模型对增加交互顺序的反应，通过堆叠额外的特征交互层。在我们的实验中，我们成功地使用了多达**8个堆叠的DCNv2层**，而没有遇到内存不足（OOM）问题，并观察到了指标的改进。这告诉我们，我们的模型从更高阶的交互中受益。

### 5.2.2 平行交互

我们检查了模型对设计用来学习相似交互的平行层的反应。例如，平行的DCN层可能分别捕获不同的交互模式。在我们的实验中，同时运行多个堆叠的DCNv2层提高了模型性能。这告诉我们，我们的模型从学习同一阶的多个特征交互中受益。

### 5.2.3 交互的非线性

DCNv2在其架构中不包含非线性。**在DCNv2中添加非线性的一种方式是使用低秩（LR）版本，在两个低秩全连接层之间使用非线性**。我们将全秩DCNv2层替换为低秩层作为基线，并使用ReLU层作为非线性进行实验。我们比较了具有不同秩值的模型，并观察到我们的模型随着非线性交互的包含而改进。

## 5.3 变体（Variants）

我们选择了几种声称比DCNv2表现更好的特征交互架构进行实验。我们提供了以下架构的实现细节，并讨论了它们如何适应我们的约束。我们还提到了学习实验的结果如何指导我们进行最终模型选择。这些实验的结果在表2中。不同架构相对于不同约束的性能总结在表3中。

### 5.3.1 Transformer

要使用Transformer进行特征交互，我们首先将我们的S 个sparse特征投影到共同的维度  D。我们将我们的dense特征分组，并将其C次投影到维度D。我们将嵌入特征投影到维度D。此外，我们将用户序列Transformer的输出U次投影到维度D。这导致最终特征集包含(S+C+U) 个tokens，每个token的维度为 D。

然后我们应用多个Transformer编码器层进行特征交互。Transformer输出token被连接并使用MLP处理。

在我们的实验中，我们设置  C = 4 和  U = 4。我们使用了不同数量的头、令牌维度和层数，如表2所示。**Transformer对内存需求很大，因此我们只能训练一个2层Transformer编码器模型而不会遇到OOM错误**。这限制了特征交互的顺序为2，这很糟糕，因为我们的模型更喜欢更高阶的特征交互。我们不能减少batch大小以适应更多层，因为参与度指标与基线相比不够高。延迟和超参数的数量也使我们不再进一步探索这种架构。

### 5.3.2 FinalMLP

我们进行了实验，重点关注调整超参数，如层数、隐藏层的大小和头的数量，即 k。我们在  k 的较小值时遇到了OOM错误。尽管我们的模型更喜欢平行交互，但我们无法使用FinalMLP获得与基线相同的性能。随着我们增加潜在维度，内存使用和延迟都增加了，而性能却没有超过基线。这使我们得出结论，基线方法在学习特征交互方面比**多头双线性融合技术**要好得多。

### 5.3.3 GDCN

我们唯一需要调整的GDCN超参数是层数。我们在每个GDCN层中使用的参数数量大约是DCNv2的两倍。这限制了我们可以学习的交互顺序，因为参数使用的额外内存。我们知道我们的模型从更高阶的特征交互中受益，所以GDCN提供的门控并不有用。

### 5.3.4 Masknet

我们尝试了两种配置：**顺序堆叠MaskNet层和并行运行它们**。需要调整的关键超参数包括投影比率、块的数量和输出维度。在我们的实验中，我们使用投影比率 = 2.0 和输出维度 = 512，只调整了块的数量。我们知道我们的模型从平行特征交互和交互中的非线性中受益。两者结合，平行MaskNet层的表现超过了基线。

这带来了3个需要调整的超参数而不是一个，但这并不是很限制。我们**使用这种架构大大增加了内存消耗和延迟**，但模型质量的提高是值得的。

### 5.3.5 SDCNv3

我们将特征交互层中的4个堆叠DCNv2层替换为声称性能更好的堆叠SDCNv3层。我们堆叠了$  d \times d/2 $特征交叉层，并尝试改变层数。我们注意到，尽管SDCNv3提高了延迟，但它在我们的数据集上收敛得不好，从而降低了save@3的离线评估。我们相信这些特征交互层，如SDCNv3，需要广泛的超参数调整，以使模型性能与我们的基线模型相似，所以我们没有进一步探索它。

### 5.3.6 DeepLight

DeepLight使用轻量级交互层。为了使比较公平，我们扩大了DeepLight模型的MLP组件。尽管如此，模型无法像基线那样学习有用的表示。此外，我们注意到，该模型报告的延迟数字是在他们论文中指定的剪枝过程之前。我们没有调整所有所需的超参数进行他们指定的剪枝过程，因为未剪枝的模型性能远低于我们的基线。

### 5.3.7 DHEN

由于我们的模型更喜欢平行交互和更高阶的交互，我们尝试使用DHEN架构结合多个特征交互层。鉴于涉及的超参数数量庞大，在计算预算内进行广泛的搜索是不可行的。我们需要调整的超参数包括层数、每层中使用的具体交互、每层的输出大小，以及与Transformer中使用的类似的输入转换。表2显示了我们尝试的一些变体。配置呈现为列表的列表，其中第一个列表代表每层，第二个列表代表层内的交互。

我们注意到DCNv2层与平行MaskNet层的结合有很好的参与度指标增益。但是DHEN框架很笨重，因为它涉及在模型的每一层之间进行分割和连接。这导致不必要的GPU内存消耗和延迟。我们还遇到了模型稳定性问题，这使我们不再进一步追求这种架构。

## 5.4 结果

从表3中我们可以看到，**运行多个MaskNet层并行实现了所有约束的良好权衡，除了延迟。为了降低模型的延迟，我们停止了在将特征交互层的输入和输出连接后传递给MLP层之前的操作**。我们还减少了MLP中隐藏层的大小。这导致指标增益略有减少，与基线相比延迟总体减少。
由于我们知道模型更喜欢更高阶的特征交互，我们在平行MaskNet层之上堆叠了4个DCNv2层。我们调整了MaskNet模型的超参数，以实现延迟不增加和参数数量净零增加，同时只增加5%的绝对内存消耗，使我们能够使用相同的batch大小。我们还使用这种新架构进行了在线A/B测试，结果在表4中。最终配置有3个平行MaskNet块，投影比率为2.0，输出维度为512，如图2b所示。我们确认这种架构不会降低可复制性，并且在我们的任何运行中都没有观察到模型稳定性问题。


[https://arxiv.org/pdf/2412.01985](https://arxiv.org/pdf/2412.01985)