---
layout: post
title: NSW
description: 
modified: 2019-04-25
tags: 
---

Yury Malkov在《Approximate nearest neighbor algorithm based on navigable small world graphs》提出了NSW算法。

# 介绍

任意软件系统的可扩展性受它的数据结构的扩展性限制。大规模分布式系统，像Bittorrent 、Skype都基于分布式hash tables。后者的数据结构具有良好的可扩展性，但它们的搜索功能只限定于exact matching。该限制的提出是因为：当一个element value做出微小变更时，会导致在hash value上出来大的变化，使得hash-based方法很难应用于range search以及相似度搜索问题上。

然而，有许多应用（比如：模式识别、图片内容检索、机器学习、推荐系统、DNA序列相似发现、语义文档检索等）需要进行相似度搜索，而非exact matching。KNNS问题是相似度搜索的一个数学公式。被定义如下：给定一个query $$q \in D$$（其中：D是所有可能对象的集合），我们需要从一个有限对象集合$$X \subseteq D$$中寻找k个最近的对象 $$P \subseteq X$$。两个对象$$o', o'' \in D$$的相近度或近似度可以定义成一个距离函数$$\delta(o', o'')$$。

KNNS问题的一个naive解法是，计算q与每个X中的element的距离函数$$\delta$$。这会导致线性搜索时间复杂度，使得它很难用于large size的datasets上。

我们的解法是：将数据结构表示成一个graph $$G(V,E)$$，其中来自X每个object $$o_i$$会与V中的一个顶点(vertex) $$v_i$$唯一关联。为query q搜索X中的最近elements的问题，就转化成了：在graph G中搜索一个vertices集合。

这为构建面向分散相似度搜索（decentralized similarity search oriented）的存储系统带来了机遇，其中物理数据位置(physical data location)不依赖于内容(content)，因为每个数据对象可以被放置在任意一个物理机器上，可以通过links相互连接，就像p2p系统一样。

在具有metric objects的graphs中的基础顶点搜索算法(basic vertex search algorithms)之一是，贪婪搜索算法(greedy search)。它有一个简单实现，可以从任意顶点初始化。为了让该算法正确工作（总是返回精确结构），该网络必须包含Delaunay graph作为它的subgraph，它与Voronoi tessellation成对偶关系。然而，与Delaunay graph相关的主要缺点是：它需要知道metric space的内部结构，这会遭受维度灾难。再者，对于上述应用，不需要precise exactness的search。因此，发现exact的最近邻的问题，可以通过ANNS来替代，从而我们不需要支持whole/exact Delaunay graph。

具有log scalibility的graphs的greedy search算法，被称为NSW graphs，它们定义在Euclidean spaces上。注意，像paper[10]中的small world模型（不是navigable small world）不会有该物性。尽管在graph中有短路径（short paths），greedy算法不会趋向于寻找它们，在结束时具有幂次的搜索复杂度。构建一个NSW graphs的解法，是为general spaces提出的，但他们通常更复杂，需要做采样、迭代、rewiring等。我们展示了small word的navigation特性可以通过一个更简单的技术来达到，无需对metric space内部结构的先验知识（例如：维度、数据的density分布）。

在本paper中，我们为该数据结构构建提出了一个简单算法，它基于一个NSW network拓朴，使用greedy search算法来做ANNS。graph G(V,E)包含了Delaunay graph的近似，具有long-range links以及small-world navigation特性。我们提出的search算法可以选择search的accuracy，无需修改结构。提出的算法不会使用坐标表示，不会假定Euclidean spaces的特性，因为它们只基于objects与query间的距离比较，因此原则上，可以应用于general metric(或non-metric) spaces的数据上。实验表明，对于欧氏数据只能很弱的维度依赖。

# 2.相关工作

kd-tree和quadra trees首先应用在kNN问题上。它们在2-3维数据表现良好（搜索复杂度接近O(logn)），但这些结构最坏case的分析有$$O(d^*N^{1-1/d})$$的复杂度，其中d是维度。

在[8]中提出了一个exact-proximity search结构，它使用Delaunay graph和greedy search算法。作者表示，在通用metric space中发现exact Delaunay graph是不可能的，为了保持search的exact，他依靠backtracking。提出的数据结构在高维数据上的构建时间为$$O(n log^2n / log log n)$$、搜索时间为$$O(n^{1-\theta(1/log log n)})$$；在低维数据上为$$0 < \alpha < 1$$。

总之，当前没有方法能有效在高维指标空间上进行有效的exact NNS。背后的原因是维数灾难。为了避免维数灾难，仍在elements数目中保留对数开销，提出减少kNN问题解的需求，使它近似（近似kNN）。

有两种近似最近邻搜索的常用定义。一种方法是：使用预定义的accuracy  $$\epsilon(\epsilon-NNS)$$。它意味着，query和在结果中的任何element间的距离不超过$$1+\epsilon$$ 乘以 query到它真正第k个最近邻的距离。这样的方法在[19-23]中有描述。另一种方法是，给定概率，保证找到离query的k个true closest的点，使用"recall"（true k最近elements的比例）。

一些结构(19-23)只能应用到欧氏空间（Euclidean space）。其它方法[24-31]则应用到通用指标空间(general metric spaces)上。更多详见[32-33]。

PI（排列索引）是一种有效的无分布算法，很适合通用指标空间。PI背后的思想是，将每个database object使用索引集合的排列进行表示，并通过与该object的距离进行排序。objects间的距离暗示着各自排列间的距离。PI对于高维数据集具有很高的precision和recall。

paper [26] 则构建一个概率化tree-like结构来在通用指标空间上进行ANNS，它基于最近邻的选择。该算法会模似现实数据。paper[27]则在构建算法时决定最近邻，在搜索时使用greedy算法。该算法的主要缺点是与dataset size的线性扩展性很差。两种算法都提供了很高的recall。

paper[9使用NSW和greedy search算法来寻找最近邻。该算法依赖于link length概率$$r^{-\gamma}$$遵循幂律的random long-range links，其中$$\gamma$$对应navigation，2维lattice对应用结果纠正。为了具有NSW特性，link length分布必须具有一个指定值$$\gamma$$。在Voronet[35]中，

# 3.核心思想

由graph G(V,E)（其中，来自集合X的objects是唯一映射到set V的顶点(vertices)上）表示的一个navigable small word网络，会通过structure S来构建。edge E的集合通过结构构建算法（structure construction algorithm）来决定。由于每个vertex会唯一映射到集合X的一个element上，我们会交替使用术语“vertex”、"element"和"object"。我们会使用术语“friends”来表示共享一个edge的vertices。vertices的列表会与vertex $$v_i$$共享一个公共edge，被称为vertex $$v_i$$的friend list。

我们会使用greedy search算法的一个variation作为一个base算法来进行k-NN search。它会遍历该graph，每次从一个element到另一个element，会选择一个离该query最近的未访问friend，直到它达到一个停止条件。见4.2节所述。

注意，在graph中的links（edges）有两个不同目的：

- 1) 存在short-range links的一个子集，被用于Delaunay graph的一个近似，由greedy search算法所需
- 2) 另一个子集是long-range links，它被用于greedy search的对数扩展。long-range links负责contructed graph的NSW属性。

结构的表现如图1所示。

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/cc71770ee6e1baf88f05f6d89c8418bf88f5999f81c455a5d627fc9135e73dcb4ae81695e8922319b44ef0990d50b377?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=402636034&amp;fname=1.jpg&amp;size=750" width="300">

图1  结构的图表示。圆（顶点）是在metric space中的data，黑色的edges是Delaunay graph的近似，红色的edges是log scaling的long range links。箭头表示greedy算法的样本路径，从entry point到query（绿色）。

该结构的构建基于所有elements上的连续插入。对于每个新进入的element，我们会发现离该结构最近的neighbors的集合（Delaunay graph 近似）。该set被连接到该element，反之亦然。随着越来越多的elements被插入到该结构，之前作为short-range links服务的links会变成long-range links，从而生成一个NSW。在该结构中的所有queries是独立的；它们可以并行完成，如果elements被随机放置到物理计算机节点上，处理query的负载可以跨物理节点共享。

# 4.搜索算法

## 4.1 basic greedy search算法

basic单个最近邻搜索算法会以从一顶点到另一顶点的方式，遍历graph G(V,E)上的edges。该算法有两个参数：query和vertext $$V_{entey\_point} \in V[G] $$，它是一个search的起始点（entry point）。从entry point开始，该算法会计算query q到当前vertext的friend list上的每个vertext的距离，接着选反具有最小距离的一个vertex。如果query和所选vertex间的距离小于当前距离（query和当前element），那么该算法会移到所选vertext上，它将变成新的current vertex。当它达到一个local minimum时，该算法会停止：一个vertex它的friend list不包含这样的vertex（比起自身，该vertex与query更近）。该算法如下：

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0e36a46204d604919c35bf4e28e10fa19c687db8d7914bd562dac32c99273a15dc7320e2ed6ce09553c1575b866a753e?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=402636034&amp;fname=a1.jpg&amp;size=750" width="300">

算法1

该element对于query $$q \in D$$都一个local minimum，可以是在该set X中的所有elements中与该query q 真实最接近（true closet）的element，或者一个false closet（一个error）。

如果结构中的每个element在它们的friend list中具有所有它的voronoi neighbors，那么这会阻止false global minima的存在。维护这样的条件等价于构建Delaunay graph，它是Voronoi diagram的两倍。

结果表明，为一个未知metric space决定exact Delaunay graph是不可能的，因为我们不能避免false global minima的存在。对于近似搜索的问题，因为近似搜索不需要整个Delaunay graph。

注意，与在[19-23]中定义的ANN的一个区别，其中它被表述成e-neighborhood。。。

## 4.2 k-NN搜索的修改版

<img alt="图片名称" src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/653fe8e81bfd735c79e7d4986d1f7f2c167250940c6fc6f309e5d5fc957780edb31a7f01adf8cc0ef15aa775875064e2?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=402636034&amp;fname=a2.jpg&amp;size=750" width="300">

算法2

# 5.数据插入算法

## 5.1 参数选择

# 6.结果与讨论



# 参考

[Approximate nearest neighbor algorithm based on navigable small world graphs](https://www.hse.ru/data/2015/03/13/1325528089/Approximate%20nearest%20neighbor%20algorithm%20b..navigable%20(Information%20Systems).pdf)